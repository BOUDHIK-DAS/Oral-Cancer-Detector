# -*- coding: utf-8 -*-
"""Untitled45.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A33TTKOtwbrkoADVDH85FYFudT2yOoGF
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

#!/bin/bash
!kaggle datasets download saswatimahapatra2015/oralcancer-mobileimage-mandley

import zipfile
zip_ref = zipfile.ZipFile('/content/oralcancer-mobileimage-mandley.zip', 'r')
zip_ref.extractall('/content')
zip_ref.close()

import tensorflow as tf
from tensorflow import keras
from keras import Sequential
from keras.layers import Dense,Conv2D,MaxPooling2D,Flatten
import cv2
import numpy as np

# Set dataset path
dataset_path = '/content/original_data'

# Create datasets with 80-20 split
train_ds = tf.keras.utils.image_dataset_from_directory(
    dataset_path,
    validation_split=0.2,
    subset="training",
    seed=42,
    image_size=(256, 256),
    batch_size=32
)

val_ds = tf.keras.utils.image_dataset_from_directory(
    dataset_path,
    validation_split=0.2,
    subset="validation",
    seed=42,
    image_size=(256, 256),
    batch_size=32
)

data_augmentation = tf.keras.Sequential([
    tf.keras.layers.RandomFlip("horizontal"),
    tf.keras.layers.RandomRotation(0.1),
    tf.keras.layers.RandomZoom(0.1),
    tf.keras.layers.RandomContrast(0.1),
])

def rgb_to_hsv_batch(images, labels):
    hsv_images = tf.image.rgb_to_hsv(images)
    return (images, hsv_images), labels

# For training dataset:
train_ds = train_ds.map(lambda x, y: (data_augmentation(x, training=True), y))  # Augment first
train_ds = train_ds.map(lambda x, y: (tf.cast(x, tf.float32) / 255.0, y))        # Normalize RGB only
train_ds = train_ds.map(rgb_to_hsv_batch)                                       # Convert to tuple of (RGB, HSV)
# Normalize HSV images too (since hsv_images are in [0,1], dividing by 255 not needed)
train_ds = train_ds.map(lambda x, y: ((x[0], x[1]), y))  # This step just passes it through, no change

# For validation dataset:
val_ds = val_ds.map(lambda x, y: (tf.cast(x, tf.float32) / 255.0, y))  # Normalize RGB only
val_ds = val_ds.map(rgb_to_hsv_batch)                                 # Convert to tuple of (RGB, HSV)
val_ds = val_ds.map(lambda x, y: ((x[0], x[1]), y))                  # No change needed here

AUTOTUNE = tf.data.AUTOTUNE
train_ds = train_ds.prefetch(buffer_size=AUTOTUNE)
val_ds = val_ds.prefetch(buffer_size=AUTOTUNE)

import tensorflow as tf

# RGB input branch
input_rgb = tf.keras.Input(shape=(256, 256, 3), name='rgb_input')
x1 = tf.keras.layers.Conv2D(32, (3,3), activation='relu')(input_rgb)
x1 = tf.keras.layers.MaxPooling2D()(x1)
x1 = tf.keras.layers.Conv2D(64, (3,3), activation='relu')(x1)
x1 = tf.keras.layers.MaxPooling2D()(x1)
x1 = tf.keras.layers.Conv2D(128, (3,3), activation='relu')(x1)
x1 = tf.keras.layers.MaxPooling2D()(x1)
x1 = tf.keras.layers.Flatten()(x1)

# HSV input branch
input_hsv = tf.keras.Input(shape=(256, 256, 3), name='hsv_input')
x2 = tf.keras.layers.Conv2D(32, (3,3), activation='relu')(input_hsv)
x2 = tf.keras.layers.MaxPooling2D()(x2)
x2 = tf.keras.layers.Conv2D(64, (3,3), activation='relu')(x2)
x2 = tf.keras.layers.MaxPooling2D()(x2)
x2 = tf.keras.layers.Conv2D(128, (3,3), activation='relu')(x2)
x2 = tf.keras.layers.MaxPooling2D()(x2)
x2 = tf.keras.layers.Flatten()(x2)

# Combine branches
combined = tf.keras.layers.concatenate([x1, x2])
combined = tf.keras.layers.Dense(128, activation='relu')(combined)
combined = tf.keras.layers.Dropout(0.5)(combined)
output = tf.keras.layers.Dense(1, activation='sigmoid')(combined)

model = tf.keras.Model(inputs=[input_rgb, input_hsv], outputs=output)

model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.summary()

from tensorflow.keras.callbacks import Callback

# Custom EarlyStopping callback
class StopOnValAccuracy(Callback):
    def __init__(self, threshold=0.8):
        super().__init__()
        self.threshold = threshold

    def on_epoch_end(self, epoch, logs=None):
        val_acc = logs.get("val_accuracy")
        if val_acc is not None and val_acc > self.threshold:
            print(f"\nStopping training â€” val_accuracy reached {val_acc:.4f}")
            self.model.stop_training = True

# Compile your model before training
model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])

# Train with early stopping
history = model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=10,
    callbacks=[StopOnValAccuracy(threshold=0.8)]
)

model.save("MODEL-HSV-2.h5")

from google.colab import files
files.download("MODEL-HSV-2.h5")

import numpy as np
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Get true labels
y_true = []
y_pred = []

for images, labels in val_ds:
    preds = model.predict(images)
    y_true.extend(labels.numpy())
    y_pred.extend(np.round(preds).flatten())  # for binary classification

# Convert to int
y_true = np.array(y_true).astype(int)
y_pred = np.array(y_pred).astype(int)

loss, accuracy = model.evaluate(val_ds)
print(f"Test Accuracy: {accuracy:.4f}")


# Classification report
print("Classification Report:")
print(classification_report(y_true, y_pred, target_names=["Benign", "Malignant"]))

# Confusion Matrix
cm = confusion_matrix(y_true, y_pred)

plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=["Benign", "Malignant"],
            yticklabels=["Benign", "Malignant"])
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix")
plt.show()

import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

# === Define paths ===
benign_path = "/content/Oral Images Dataset/original_data/benign_lesions"
malignant_path = "/content/Oral Images Dataset/original_data/malignant_lesions"

# === Initialize containers ===
rgb_inputs = []
hsv_inputs = []
y_true = []

# === Helper to load images and labels ===
def load_images_from_folder(folder_path, label):
    for filename in os.listdir(folder_path):
        if filename.lower().endswith((".jpg", ".jpeg", ".png")):
            image_path = os.path.join(folder_path, filename)
            img_bgr = cv2.imread(image_path)

            if img_bgr is None:
                print(f"Warning: Could not read {filename}")
                continue

            img_bgr = cv2.resize(img_bgr, (256, 256))
            img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB) / 255.0
            img_hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV) /255.0

            rgb_inputs.append(img_rgb)
            hsv_inputs.append(img_hsv)
            y_true.append(label)  # 0 for benign, 1 for malignant

# === Load both classes ===
load_images_from_folder(benign_path, label=0)
load_images_from_folder(malignant_path, label=1)

# === Convert to NumPy arrays ===
rgb_batch = np.array(rgb_inputs, dtype=np.float32)
hsv_batch = np.array(hsv_inputs, dtype=np.float32)
y_true = np.array(y_true)

# === Predict probabilities ===
y_scores = model.predict([rgb_batch, hsv_batch]).flatten()

# === Calculate ROC curve and AUC ===
fpr, tpr, thresholds = roc_curve(y_true, y_scores)
roc_auc = auc(fpr, tpr)

# === Print AUC ===
print(f"AUC: {roc_auc:.4f}")

# === Plot ROC curve ===
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, label=f'ROC Curve (AUC = {roc_auc:.2f})', color='blue', linewidth=2)
plt.plot([0, 1], [0, 1], 'k--', label='Random Guess')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve for Oral Cancer Detection')
plt.legend(loc='lower right')
plt.grid(True)
plt.tight_layout()
plt.show()

from tensorflow.keras.utils import plot_model
plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)

import matplotlib.pyplot as plt
from sklearn.metrics import auc

# ROC data for model 1
fpr1 = [0.0, 0.0, 0.0, 0.03448, 0.03448, 0.06897, 0.06897, 0.13793, 0.13793, 0.17241, 0.17241, 0.24138, 0.24138, 0.27586, 0.27586, 0.37931, 0.37931, 0.89655, 0.89655, 1.0]
tpr1 = [0.0, 0.02857, 0.14286, 0.14286, 0.17143, 0.17143, 0.2, 0.2, 0.42857, 0.42857, 0.45714, 0.45714, 0.48571, 0.48571, 0.85714, 0.85714, 0.97143, 0.97143, 1.0, 1.0]
auc1 = auc(fpr1, tpr1)



# Plot all 3 ROC curves
plt.figure(figsize=(8, 6))
plt.plot(fpr1, tpr1, label=f'Model 1 (AUC = {auc1:.2f})', color='blue', linewidth=2)

plt.plot([0, 1], [0, 1], 'k--', label='Random Guess')

# Formatting
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve Comparison')
plt.legend(loc='lower right')
plt.grid(True)
plt.tight_layout()
plt.show()

import tensorflow as tf
import numpy as np
import cv2
import matplotlib.pyplot as plt
import os

# Function to convert batch of RGB images to HSV and YCrCb
def rgb_to_all_colorspaces(images, labels=None):
    def convert_to_ycrcb(img_batch_np):
        img_batch_np = img_batch_np * 255.0
        img_batch_np = img_batch_np.astype(np.uint8)
        ycrcb_batch = np.array([cv2.cvtColor(img, cv2.COLOR_RGB2YCrCb) for img in img_batch_np])
        ycrcb_batch = ycrcb_batch.astype(np.float32) / 255.0
        return ycrcb_batch

    ycrcb_images = tf.numpy_function(func=convert_to_ycrcb, inp=[images], Tout=tf.float32)
    ycrcb_images.set_shape(images.shape[:-1] + (3,))
    hsv_images = tf.image.rgb_to_hsv(images)

    return (images, hsv_images, ycrcb_images), labels

# Load and preprocess multiple images
filenames = ['TC1.jpeg', 'TC2.jpg', 't7.jpg']
folder_path = "/content/"

rgb_list = []

for fname in filenames:
    img_path = os.path.join(folder_path, fname)
    img_bgr = cv2.imread(img_path)
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    img_rgb = cv2.resize(img_rgb, (256, 256))
    img_rgb = img_rgb.astype(np.float32) / 255.0
    rgb_list.append(img_rgb)

# Convert to batch tensor
rgb_batch = np.stack(rgb_list, axis=0)
(rgb_imgs, hsv_imgs, ycrcb_imgs), _ = rgb_to_all_colorspaces(tf.convert_to_tensor(rgb_batch), None)

# Convert to numpy for plotting
rgb_np = rgb_imgs.numpy()
hsv_np = hsv_imgs.numpy()
ycrcb_np = ycrcb_imgs.numpy()

# Plot all images (each row = one image, columns = color spaces)
num_images = len(filenames)
plt.figure(figsize=(10, 4 * num_images))

for i in range(num_images):
    plt.subplot(num_images, 3, i*3 + 1)
    plt.imshow(rgb_np[i])
    plt.title(f"{filenames[i]} - RGB")
    plt.axis('off')

    plt.subplot(num_images, 3, i*3 + 2)
    plt.imshow(hsv_np[i])
    plt.title(f"{filenames[i]} - HSV")
    plt.axis('off')

    plt.subplot(num_images, 3, i*3 + 3)
    plt.imshow(ycrcb_np[i])
    plt.title(f"{filenames[i]} - YCrCb")
    plt.axis('off')

plt.tight_layout()
plt.show()

